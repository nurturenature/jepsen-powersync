## A Dart CLI fuzzer for PowerSync

Jepsen has been able to find and exhibit non Causally Consistent behavior when testing PowerSync.

But Jepsen is a bit of a heavy lift:
- full featured generic environment
  - each client is its own container
  - written in Clojure
  - analyzes the test history
    - with acyclic graphs for transaction values
    - using Adya's full blown SQL consistency models and research

So `powersync_fuzz` was developed:
- written as a minimalistic Dart CLI application
  - uses existing Powersync Dart client libraries
  - easier to understand, modify
- analyzes the test history dynamically
  - just for Causal Consistency
  - uses simple/efficient Lists of integers for client state

PowerSync clients are Dart `Isolate`s.

SQL transactions of reads and writes to random keys:
- are generated by a `Stream.periodic()` that's `listen()`ed to in `main()`
- the transaction request is `SendPort`ed by `main()` to a random client `Isolate`'s `ReceivePort`
- the transaction result is `SendPort`ed by the client `Isolate` to `main()`'s `ReceivePort`

A behavioral nemesis:
- normal behavior
  - `db.disconnect()`/`db.connect()`
  - `db.close()`/`Isolate.spawn()`
- faults
  - network partitions
  - kills/pauses
introduces normal/fault behaviors at random intervals using a `Stream` that flip flops between states:
```dart
// Stream of disconnect/connect messages
_disconnectConnectStream = () async* {
  while (true) {
    await utils.futureSleep(_rng.nextInt(_maxInterval + 1));
    yield await _locks[Nemeses.disconnect]!.synchronized<ConnectionStates>(
      () {
        return _connectionState.flipFlop();
      },
    );
  }
};
```

The `Stream`s of behaviors are subscribed and `listen()`ed to and acted on in `main()`:
```dart
// Subscription to a Stream of network partition/heal messages
_partitionSubscription = _partitionStream().listen((
   partitionStateMessage,
 ) async {
   await _locks[Nemeses.partition]!.synchronized(() async {
     await Partition.partition(powerSyncHost, partitionStateMessage)
     log.info('nemesis: partition: ${partitionStateMessage.name}');
   });
 });
```

----

### Max Write Wins Data Model

Database is a Max Write Wins key/value register of integer/integer:
```SQL
CREATE TABLE IF NOT EXISTS public.mww (
    id TEXT NOT NULL,
    k INTEGER NOT NULL UNIQUE,
    v INTEGER NOT NULL,
    CONSTRAINT mww_pkey PRIMARY KEY (id)
);
```

On writes the maximum, transaction or row, value wins.
The `BackendConnector` updates PostgreSQL:
```dart
// max write wins, so GREATEST() value of v
final v = crudEntry.opData!['v'] as int;
patch = await tx.execute(
  'UPDATE ${table.name} SET v = GREATEST($v, ${table.name}.v) WHERE id = \'${crudEntry.id}\' RETURNING *',
);
```

Values written in a transaction are monotonic per key.

Values read in a transaction are monotonic per key.

Transactions are atomic.

Each client will read values in Causally Consistent way.

----

### Causal Consistency

Every client transaction is checked for Causal Consistency:

- Read Your Writes: clients always read all of their previous writes
- Monotonic Reads: all reads read the same or greater state
- Monotonic Writes: clients read other clients writes in write order
- Writes Follow Reads: a read of a value includes all of the known state at the time the value was written

The fuzzer stops the test run when any transaction violates Causal Consistency and attempts to explain the reason:
```dart
// reasons why a clientState[key] value is what it is
enum _Reasons {
  initialValue,
  myPreviousRead,
  myPreviousWrite,
  writesFollowsRead,
}
```
```log
[main] [SEVERE] read of {0: 387} is less than expected read of {0: 548}, expected because myPreviousRead, in op: {clientNum: 2, clientType: ps, id: 61, table: mww, type: ok, value: [{f: readAll, v: {0: 387, ...}}, {f: writeSome, v: {9: 694, ...}}]}
```

----

### CLI

CLI entrypoint is `bin/powersync_fuzz.dart`.

Library code is in `lib/`.

Can manually compile with `./compile-fuzz.sh`.

Runtime requires manual download of PowerSync's SQLite core `./download-powersync-sqlite-core.sh`.

```bash
$ ./powersync_fuzz --help
Usage: dart powersync_(http|fuzz).dart <flags> [arguments]
    --table                   table name/type
                              [lww, mww (default)]
-c, --clients                 number of PowerSync clients
                              (defaults to "5")
    --[no-]postgresql         include a postgresql client
-k, --keys                    number of keys
                              (defaults to "100")
-r, --rate                    txn rate in txn per second
                              (defaults to "30")
-t, --time                    time of test in seconds
                              (defaults to "100")
    --maxTxnLen               max transaction length
                              (defaults to "4")
    --[no-]disconnect         call disconnect/connect API at interval
    --[no-]stop               stop/start Workers at interval
    --[no-]kill               kill/start Workers at interval
    --[no-]partition          partition Workers from PowerSync Service at interval
    --[no-]pause              pause/resume client Worker Isolates at interval
-i, --interval                invoke nemeses every 0 <= random <= interval * 2 seconds
                              (defaults to "5")
    --httpPort                http_endpoint port
                              (defaults to "8089")
-l, --logLevel                log level
                              (defaults to "ALL")
    --PG_DATABASE_HOST        (defaults to "pg-db")
    --PG_DATABASE_PORT        (defaults to "5432")
    --PG_DATABASE_NAME        (defaults to "postgres")
    --PG_DATABASE_USER        (defaults to "postgres")
    --PG_DATABASE_PASSWORD    (defaults to "mypassword")
    --POWERSYNC_URL           (defaults to "http://powersync:8080")
-h, --help                    Print this usage information.
```

----

### Return Codes
<table>
<tr><td>0</td><td>success</td></tr>

<tr><td>1</td><td>final reads violate Strong Convergence</td></tr>
<tr><td>2</td><td>Causal Consistency violation in a local SQLite3 txn</td></tr>
<tr><td>3</td><td>Causal Consistency violation in a PostgreSQL txn</td></tr>

<tr><td>10</td><td>invalid data in PowerSync db</td></tr>
<tr><td>11</td><td>invalid data in PostgreSQL db</td></tr>

<tr><td>21</td><td>PostgreSQL error</td></tr>

<tr><td>30</td><td>BackendConnector upload failure</td></tr>

<tr><td>100</td><td>invalid state due to coding error</td></tr>
</table>

----

### Nemesis Implementation

#### --disconnect

```dart
await db.disconnect();

await db.connect(connector: connector);
```

#### --partition

```dart
// Partition inbound traffic.
await Process.run('/usr/sbin/iptables', [
  '-A',
  'INPUT',
  '-s',
  host,
  '-j',
  'DROP',
  '-w',
]);
  
// Partition outbound traffic.
await Process.run('/usr/sbin/iptables', [
  '-A',
  'OUTPUT',
  '-d',
  host,
  '-j',
  'DROP',
  '-w',
]);
  
// Partition no traffic
await Process.run('/usr/sbin/iptables', ['-F', '-w']);
await Process.run('/usr/sbin/iptables', ['-X', '-w']);
```

#### --pause

```dart
// Pause.
_resumeCapability = _isolate.pause();

// Resume.
_isolate.resume(_resumeCapability!);
```

#### --stop

```dart
// Stop.
// Database in Isolate client is closed, which disconnects, frees resources
await db.close();
// Isolate is killed immediately, do not wait for next event loop opportunity
Isolate.kill(priority: Isolate.immediate);

// Start.
//  - newly spawned Isolate client
//  - SQLite3 data files are preserved
//  - new PowerSync db connection initialized in client
```

#### --kill

```dart
// Kill.
// no warning, interaction, e.g. disconnect, close, etc, with PowerSync database
// Isolate is killed immediately, do not wait for next event loop opportunity
Isolate.kill(priority: Isolate.immediate);

// Start.
//  - newly spawned Isolate client
//  - SQLite3 data files are preserved
//  - new PowerSync db connection initialized in client
```

----

### Docker Environment

The `docker` directory has helper scripts to build, bring up a PowerSync cluster and fuzzing node, and run a fuzzing command:
```bash
cd jepsen-powersync/docker

# conditionally cleanup and build a fuzzing environment, bring up a full PowerSync cluster and fuzzing node
./powersync-fuzz-down.sh && ./powersync-fuzz-build.sh && ./powersync-fuzz-up.sh

# run a fuzz test on the fuzzing node
./powersync-fuzz-run.sh ./powersync_fuzz --table mww --clients 10 --rate 10 --time 100 --postgresql --disconnect --no-stop --no-kill --partition --no-pause --interval 5

# download the test run's output from the container to the local host for local analysis
docker cp powersync-fuzz-node:/jepsen/jepsen-powersync/powersync_endpoint/powersync_fuzz.log .
```

----

### Reproducing Anomalies

#### GitHub Actions

The repository has a full suite of actions to test PowerSync under a range of normal conditions and faulty environments.

[https://github.com/nurturenature/jepsen-powersync/actions](https://github.com/nurturenature/jepsen-powersync/actions)

The test artifacts can be large. They contain:
- `powersync_fuzz` logs (`logLevel=finest`)
- PowerSync Service logs
- PostgreSQL logs (`log_statement=ALL`)
- MongoDB logs

#### Local Host - Helper Script to Loop Until Error

In the `docker` directory there's a script that builds a fuzzing environment and just loops until it finds:
- exit code > $SUSPECT_EXIT_CODE
  - exit code  1: divergent final reads, i.e. not Strong Convergence
  - exit code  2: non-monotonic read, i.e. the database state goes back in time
  - exit code 10: read of a suddenly empty local database
```bash
cd jepsen-powersync/docker

# simplest CLI args most likely to produce a non-monotonic or empty read
export SUSPECT_EXIT_CODE=2
./powersync-fuzz-loop.sh ./powersync_fuzz --table mww --clients 10 --rate 10 --time 100 --postgresql --disconnect --no-stop --no-kill --partition --no-pause --interval 5
```
